// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Position position
//
// swagger:model position
type Position struct {

	// Average price of trades that built this position
	// Required: true
	AveragePrice *float64 `json:"average_price"`

	// Only for options, average price in USD
	AveragePriceUsd float64 `json:"average_price_usd,omitempty"`

	// Delta parameter
	// Required: true
	Delta *float64 `json:"delta"`

	// direction
	// Required: true
	Direction Direction `json:"direction"`

	// Only for futures, estimated liquidation price
	EstimatedLiquidationPrice float64 `json:"estimated_liquidation_price,omitempty"`

	// Floating profit or loss
	// Required: true
	FloatingProfitLoss *float64 `json:"floating_profit_loss"`

	// Only for options, floating profit or loss in USD
	FloatingProfitLossUsd float64 `json:"floating_profit_loss_usd,omitempty"`

	// Current index price
	// Required: true
	IndexPrice *float64 `json:"index_price"`

	// Initial margin
	// Required: true
	InitialMargin *float64 `json:"initial_margin"`

	// instrument name
	// Required: true
	InstrumentName InstrumentName `json:"instrument_name"`

	// kind
	// Required: true
	Kind Kind `json:"kind"`

	// Maintenance margin
	// Required: true
	MaintenanceMargin *float64 `json:"maintenance_margin"`

	// Current mark price for position's instrument
	// Required: true
	MarkPrice *float64 `json:"mark_price"`

	// Open orders margin
	// Required: true
	OpenOrdersMargin *float64 `json:"open_orders_margin"`

	// Realized profit or loss
	// Required: true
	RealizedProfitLoss *float64 `json:"realized_profit_loss"`

	// Last settlement price for position's instrument 0 if instrument wasn't settled yet
	// Required: true
	SettlementPrice *float64 `json:"settlement_price"`

	// Position size for futures size in quote currency (e.g. USD), for options size is in base currency (e.g. BTC)
	// Required: true
	Size *float64 `json:"size"`

	// Only for futures, position size in base currency
	SizeCurrency float64 `json:"size_currency,omitempty"`

	// Profit or loss from position
	// Required: true
	TotalProfitLoss *float64 `json:"total_profit_loss"`
}

// Validate validates this position
func (m *Position) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAveragePrice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDelta(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDirection(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFloatingProfitLoss(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIndexPrice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInitialMargin(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInstrumentName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateKind(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMaintenanceMargin(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMarkPrice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOpenOrdersMargin(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRealizedProfitLoss(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSettlementPrice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSize(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTotalProfitLoss(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Position) validateAveragePrice(formats strfmt.Registry) error {

	if err := validate.Required("average_price", "body", m.AveragePrice); err != nil {
		return err
	}

	return nil
}

func (m *Position) validateDelta(formats strfmt.Registry) error {

	if err := validate.Required("delta", "body", m.Delta); err != nil {
		return err
	}

	return nil
}

func (m *Position) validateDirection(formats strfmt.Registry) error {

	if err := m.Direction.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("direction")
		}
		return err
	}

	return nil
}

func (m *Position) validateFloatingProfitLoss(formats strfmt.Registry) error {

	if err := validate.Required("floating_profit_loss", "body", m.FloatingProfitLoss); err != nil {
		return err
	}

	return nil
}

func (m *Position) validateIndexPrice(formats strfmt.Registry) error {

	if err := validate.Required("index_price", "body", m.IndexPrice); err != nil {
		return err
	}

	return nil
}

func (m *Position) validateInitialMargin(formats strfmt.Registry) error {

	if err := validate.Required("initial_margin", "body", m.InitialMargin); err != nil {
		return err
	}

	return nil
}

func (m *Position) validateInstrumentName(formats strfmt.Registry) error {

	if err := m.InstrumentName.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("instrument_name")
		}
		return err
	}

	return nil
}

func (m *Position) validateKind(formats strfmt.Registry) error {

	if err := m.Kind.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("kind")
		}
		return err
	}

	return nil
}

func (m *Position) validateMaintenanceMargin(formats strfmt.Registry) error {

	if err := validate.Required("maintenance_margin", "body", m.MaintenanceMargin); err != nil {
		return err
	}

	return nil
}

func (m *Position) validateMarkPrice(formats strfmt.Registry) error {

	if err := validate.Required("mark_price", "body", m.MarkPrice); err != nil {
		return err
	}

	return nil
}

func (m *Position) validateOpenOrdersMargin(formats strfmt.Registry) error {

	if err := validate.Required("open_orders_margin", "body", m.OpenOrdersMargin); err != nil {
		return err
	}

	return nil
}

func (m *Position) validateRealizedProfitLoss(formats strfmt.Registry) error {

	if err := validate.Required("realized_profit_loss", "body", m.RealizedProfitLoss); err != nil {
		return err
	}

	return nil
}

func (m *Position) validateSettlementPrice(formats strfmt.Registry) error {

	if err := validate.Required("settlement_price", "body", m.SettlementPrice); err != nil {
		return err
	}

	return nil
}

func (m *Position) validateSize(formats strfmt.Registry) error {

	if err := validate.Required("size", "body", m.Size); err != nil {
		return err
	}

	return nil
}

func (m *Position) validateTotalProfitLoss(formats strfmt.Registry) error {

	if err := validate.Required("total_profit_loss", "body", m.TotalProfitLoss); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Position) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Position) UnmarshalBinary(b []byte) error {
	var res Position
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
