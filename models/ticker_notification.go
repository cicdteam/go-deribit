// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// TickerNotification ticker notification
//
// swagger:model ticker_notification
type TickerNotification struct {

	// ask iv
	AskIv AskIv `json:"ask_iv,omitempty"`

	// best ask amount
	// Required: true
	BestAskAmount BestAskAmount `json:"best_ask_amount"`

	// best ask price
	// Required: true
	BestAskPrice BestAskPrice `json:"best_ask_price"`

	// best bid amount
	// Required: true
	BestBidAmount BestBidAmount `json:"best_bid_amount"`

	// best bid price
	// Required: true
	BestBidPrice BestBidPrice `json:"best_bid_price"`

	// bid iv
	BidIv BidIv `json:"bid_iv,omitempty"`

	// current funding
	CurrentFunding CurrentFunding `json:"current_funding,omitempty"`

	// delivery price
	DeliveryPrice DeliveryPrice `json:"delivery_price,omitempty"`

	// funding 8h
	Funding8h Funding8h `json:"funding_8h,omitempty"`

	// greeks
	Greeks *Greeks `json:"greeks,omitempty"`

	// index price
	// Required: true
	IndexPrice IndexPrice `json:"index_price"`

	// instrument name
	// Required: true
	InstrumentName InstrumentName `json:"instrument_name"`

	// interest rate
	InterestRate InterestRate `json:"interest_rate,omitempty"`

	// last price
	// Required: true
	LastPrice LastPrice `json:"last_price"`

	// mark iv
	MarkIv MarkIv `json:"mark_iv,omitempty"`

	// mark price
	// Required: true
	MarkPrice MarkPrice `json:"mark_price"`

	// max price
	// Required: true
	MaxPrice MaxPrice `json:"max_price"`

	// min price
	// Required: true
	MinPrice MinPrice `json:"min_price"`

	// open interest
	// Required: true
	OpenInterest OpenInterest `json:"open_interest"`

	// settlement price
	SettlementPrice SettlementPrice `json:"settlement_price,omitempty"`

	// state
	// Required: true
	State BookState `json:"state"`

	// stats
	// Required: true
	Stats *Stats `json:"stats"`

	// timestamp
	// Required: true
	Timestamp Timestamp `json:"timestamp"`

	// underlying index
	UnderlyingIndex UnderlyingIndex `json:"underlying_index,omitempty"`

	// underlying price
	UnderlyingPrice UnderlyingPrice `json:"underlying_price,omitempty"`
}

// Validate validates this ticker notification
func (m *TickerNotification) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAskIv(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBestAskAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBestAskPrice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBestBidAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBestBidPrice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBidIv(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCurrentFunding(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDeliveryPrice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFunding8h(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGreeks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIndexPrice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInstrumentName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInterestRate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastPrice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMarkIv(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMarkPrice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMaxPrice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMinPrice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOpenInterest(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSettlementPrice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStats(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUnderlyingIndex(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUnderlyingPrice(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TickerNotification) validateAskIv(formats strfmt.Registry) error {

	if swag.IsZero(m.AskIv) { // not required
		return nil
	}

	if err := m.AskIv.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("ask_iv")
		}
		return err
	}

	return nil
}

func (m *TickerNotification) validateBestAskAmount(formats strfmt.Registry) error {

	if err := m.BestAskAmount.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("best_ask_amount")
		}
		return err
	}

	return nil
}

func (m *TickerNotification) validateBestAskPrice(formats strfmt.Registry) error {

	if err := m.BestAskPrice.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("best_ask_price")
		}
		return err
	}

	return nil
}

func (m *TickerNotification) validateBestBidAmount(formats strfmt.Registry) error {

	if err := m.BestBidAmount.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("best_bid_amount")
		}
		return err
	}

	return nil
}

func (m *TickerNotification) validateBestBidPrice(formats strfmt.Registry) error {

	if err := m.BestBidPrice.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("best_bid_price")
		}
		return err
	}

	return nil
}

func (m *TickerNotification) validateBidIv(formats strfmt.Registry) error {

	if swag.IsZero(m.BidIv) { // not required
		return nil
	}

	if err := m.BidIv.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("bid_iv")
		}
		return err
	}

	return nil
}

func (m *TickerNotification) validateCurrentFunding(formats strfmt.Registry) error {

	if swag.IsZero(m.CurrentFunding) { // not required
		return nil
	}

	if err := m.CurrentFunding.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("current_funding")
		}
		return err
	}

	return nil
}

func (m *TickerNotification) validateDeliveryPrice(formats strfmt.Registry) error {

	if swag.IsZero(m.DeliveryPrice) { // not required
		return nil
	}

	if err := m.DeliveryPrice.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("delivery_price")
		}
		return err
	}

	return nil
}

func (m *TickerNotification) validateFunding8h(formats strfmt.Registry) error {

	if swag.IsZero(m.Funding8h) { // not required
		return nil
	}

	if err := m.Funding8h.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("funding_8h")
		}
		return err
	}

	return nil
}

func (m *TickerNotification) validateGreeks(formats strfmt.Registry) error {

	if swag.IsZero(m.Greeks) { // not required
		return nil
	}

	if m.Greeks != nil {
		if err := m.Greeks.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("greeks")
			}
			return err
		}
	}

	return nil
}

func (m *TickerNotification) validateIndexPrice(formats strfmt.Registry) error {

	if err := m.IndexPrice.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("index_price")
		}
		return err
	}

	return nil
}

func (m *TickerNotification) validateInstrumentName(formats strfmt.Registry) error {

	if err := m.InstrumentName.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("instrument_name")
		}
		return err
	}

	return nil
}

func (m *TickerNotification) validateInterestRate(formats strfmt.Registry) error {

	if swag.IsZero(m.InterestRate) { // not required
		return nil
	}

	if err := m.InterestRate.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("interest_rate")
		}
		return err
	}

	return nil
}

func (m *TickerNotification) validateLastPrice(formats strfmt.Registry) error {

	if err := m.LastPrice.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("last_price")
		}
		return err
	}

	return nil
}

func (m *TickerNotification) validateMarkIv(formats strfmt.Registry) error {

	if swag.IsZero(m.MarkIv) { // not required
		return nil
	}

	if err := m.MarkIv.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("mark_iv")
		}
		return err
	}

	return nil
}

func (m *TickerNotification) validateMarkPrice(formats strfmt.Registry) error {

	if err := m.MarkPrice.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("mark_price")
		}
		return err
	}

	return nil
}

func (m *TickerNotification) validateMaxPrice(formats strfmt.Registry) error {

	if err := m.MaxPrice.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("max_price")
		}
		return err
	}

	return nil
}

func (m *TickerNotification) validateMinPrice(formats strfmt.Registry) error {

	if err := m.MinPrice.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("min_price")
		}
		return err
	}

	return nil
}

func (m *TickerNotification) validateOpenInterest(formats strfmt.Registry) error {

	if err := m.OpenInterest.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("open_interest")
		}
		return err
	}

	return nil
}

func (m *TickerNotification) validateSettlementPrice(formats strfmt.Registry) error {

	if swag.IsZero(m.SettlementPrice) { // not required
		return nil
	}

	if err := m.SettlementPrice.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("settlement_price")
		}
		return err
	}

	return nil
}

func (m *TickerNotification) validateState(formats strfmt.Registry) error {

	if err := m.State.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("state")
		}
		return err
	}

	return nil
}

func (m *TickerNotification) validateStats(formats strfmt.Registry) error {

	if err := validate.Required("stats", "body", m.Stats); err != nil {
		return err
	}

	if m.Stats != nil {
		if err := m.Stats.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("stats")
			}
			return err
		}
	}

	return nil
}

func (m *TickerNotification) validateTimestamp(formats strfmt.Registry) error {

	if err := m.Timestamp.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("timestamp")
		}
		return err
	}

	return nil
}

func (m *TickerNotification) validateUnderlyingIndex(formats strfmt.Registry) error {

	if swag.IsZero(m.UnderlyingIndex) { // not required
		return nil
	}

	if err := m.UnderlyingIndex.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("underlying_index")
		}
		return err
	}

	return nil
}

func (m *TickerNotification) validateUnderlyingPrice(formats strfmt.Registry) error {

	if swag.IsZero(m.UnderlyingPrice) { // not required
		return nil
	}

	if err := m.UnderlyingPrice.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("underlying_price")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TickerNotification) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TickerNotification) UnmarshalBinary(b []byte) error {
	var res TickerNotification
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
