// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Settlement settlement
//
// swagger:model settlement
type Settlement struct {

	// funded amount (bankruptcy only)
	Funded float64 `json:"funded,omitempty"`

	// funding (in base currency ; settlement for perpetual product only)
	// Required: true
	Funding *float64 `json:"funding"`

	// underlying index price at time of event (in quote currency; settlement and delivery only)
	// Required: true
	IndexPrice *float64 `json:"index_price"`

	// instrument name (settlement and delivery only)
	// Required: true
	InstrumentName *string `json:"instrument_name"`

	// mark price for at the settlement time (in quote currency; settlement and delivery only)
	MarkPrice float64 `json:"mark_price,omitempty"`

	// position size (in quote currency; settlement and delivery only)
	// Required: true
	Position *float64 `json:"position"`

	// profit and loss (in base currency; settlement and delivery only)
	ProfitLoss float64 `json:"profit_loss,omitempty"`

	// value of session bankrupcy (in base currency; bankruptcy only)
	SessionBankrupcy float64 `json:"session_bankrupcy,omitempty"`

	// total value of session profit and losses (in base currency)
	// Required: true
	SessionProfitLoss *float64 `json:"session_profit_loss"`

	// total amount of paid taxes/fees (in base currency; bankruptcy only)
	SessionTax float64 `json:"session_tax,omitempty"`

	// rate of paid texes/fees (in base currency; bankruptcy only)
	SessionTaxRate float64 `json:"session_tax_rate,omitempty"`

	// the amount of the socialized losses (in base currency; bankruptcy only)
	Socialized float64 `json:"socialized,omitempty"`

	// timestamp
	// Required: true
	Timestamp Timestamp `json:"timestamp"`

	// type
	// Required: true
	Type SettlementType `json:"type"`
}

// Validate validates this settlement
func (m *Settlement) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFunding(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIndexPrice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInstrumentName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePosition(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSessionProfitLoss(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Settlement) validateFunding(formats strfmt.Registry) error {

	if err := validate.Required("funding", "body", m.Funding); err != nil {
		return err
	}

	return nil
}

func (m *Settlement) validateIndexPrice(formats strfmt.Registry) error {

	if err := validate.Required("index_price", "body", m.IndexPrice); err != nil {
		return err
	}

	return nil
}

func (m *Settlement) validateInstrumentName(formats strfmt.Registry) error {

	if err := validate.Required("instrument_name", "body", m.InstrumentName); err != nil {
		return err
	}

	return nil
}

func (m *Settlement) validatePosition(formats strfmt.Registry) error {

	if err := validate.Required("position", "body", m.Position); err != nil {
		return err
	}

	return nil
}

func (m *Settlement) validateSessionProfitLoss(formats strfmt.Registry) error {

	if err := validate.Required("session_profit_loss", "body", m.SessionProfitLoss); err != nil {
		return err
	}

	return nil
}

func (m *Settlement) validateTimestamp(formats strfmt.Registry) error {

	if err := m.Timestamp.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("timestamp")
		}
		return err
	}

	return nil
}

func (m *Settlement) validateType(formats strfmt.Registry) error {

	if err := m.Type.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("type")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Settlement) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Settlement) UnmarshalBinary(b []byte) error {
	var res Settlement
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
