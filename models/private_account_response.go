// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// PrivateAccountResponse private account response
//
// swagger:model private_account_response
type PrivateAccountResponse struct {

	// result
	// Required: true
	Result *PrivateAccountResponseResult `json:"result"`
}

// Validate validates this private account response
func (m *PrivateAccountResponse) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateResult(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PrivateAccountResponse) validateResult(formats strfmt.Registry) error {

	if err := validate.Required("result", "body", m.Result); err != nil {
		return err
	}

	if m.Result != nil {
		if err := m.Result.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("result")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PrivateAccountResponse) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PrivateAccountResponse) UnmarshalBinary(b []byte) error {
	var res PrivateAccountResponse
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PrivateAccountResponseResult private account response result
//
// swagger:model PrivateAccountResponseResult
type PrivateAccountResponseResult struct {

	// The account's available funds
	// Required: true
	AvailableFunds *float64 `json:"available_funds"`

	// The account's available to withdrawal funds
	// Required: true
	AvailableWithdrawalFunds *float64 `json:"available_withdrawal_funds"`

	// The account's balance
	// Required: true
	Balance *float64 `json:"balance"`

	// The selected currency
	// Required: true
	Currency *string `json:"currency"`

	// The sum of position deltas
	// Required: true
	DeltaTotal *float64 `json:"delta_total"`

	// The deposit address for the account (if available)
	DepositAddress string `json:"deposit_address,omitempty"`

	// User email (available when parameter `extended` = `true`)
	// Required: true
	Email *string `json:"email"`

	// The account's current equity
	// Required: true
	Equity *float64 `json:"equity"`

	// Futures profit and Loss
	// Required: true
	FuturesPl *float64 `json:"futures_pl"`

	// Futures session realized profit and Loss
	// Required: true
	FuturesSessionRpl *float64 `json:"futures_session_rpl"`

	// Futures session unrealized profit and Loss
	// Required: true
	FuturesSessionUpl *float64 `json:"futures_session_upl"`

	// Account id (available when parameter `extended` = `true`)
	// Required: true
	ID *int64 `json:"id"`

	// The account's initial margin
	// Required: true
	InitialMargin *float64 `json:"initial_margin"`

	// The maintenance margin.
	// Required: true
	MaintenanceMargin *float64 `json:"maintenance_margin"`

	// The account's margin balance
	MarginBalance float64 `json:"margin_balance,omitempty"`

	// Options summary delta
	// Required: true
	OptionsDelta *float64 `json:"options_delta"`

	// Options summary gamma
	// Required: true
	OptionsGamma *float64 `json:"options_gamma"`

	// Options profit and Loss
	// Required: true
	OptionsPl *float64 `json:"options_pl"`

	// Options session realized profit and Loss
	// Required: true
	OptionsSessionRpl *float64 `json:"options_session_rpl"`

	// Options session unrealized profit and Loss
	// Required: true
	OptionsSessionUpl *float64 `json:"options_session_upl"`

	// Options summary theta
	// Required: true
	OptionsTheta *float64 `json:"options_theta"`

	// Options summary vega
	// Required: true
	OptionsVega *float64 `json:"options_vega"`

	// `true` when portfolio margining is enabled for user
	PortfolioMarginingEnabled bool `json:"portfolio_margining_enabled,omitempty"`

	// Projected initial margin (for portfolio margining users)
	ProjectedInitialMargin float64 `json:"projected_initial_margin,omitempty"`

	// Projected maintenance margin (for portfolio margining users)
	ProjectedMaintenanceMargin float64 `json:"projected_maintenance_margin,omitempty"`

	// Session funding
	// Required: true
	SessionFunding *float64 `json:"session_funding"`

	// Session realized profit and loss
	// Required: true
	SessionRpl *float64 `json:"session_rpl"`

	// Session unrealized profit and loss
	// Required: true
	SessionUpl *float64 `json:"session_upl"`

	// System generated user nickname (available when parameter `extended` = `true`)
	// Required: true
	SystemName *string `json:"system_name"`

	// Whether two factor authentication is enabled (available when parameter `extended` = `true`)
	// Required: true
	TfaEnabled *bool `json:"tfa_enabled"`

	// Profit and loss
	// Required: true
	TotalPl *float64 `json:"total_pl"`

	// Account type (available when parameter `extended` = `true`)
	// Required: true
	// Enum: [main subaccount]
	Type *string `json:"type"`

	// Account name (given by user) (available when parameter `extended` = `true`)
	// Required: true
	Username *string `json:"username"`
}

// Validate validates this private account response result
func (m *PrivateAccountResponseResult) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAvailableFunds(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAvailableWithdrawalFunds(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBalance(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDeltaTotal(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEmail(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEquity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFuturesPl(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFuturesSessionRpl(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFuturesSessionUpl(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInitialMargin(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMaintenanceMargin(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOptionsDelta(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOptionsGamma(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOptionsPl(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOptionsSessionRpl(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOptionsSessionUpl(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOptionsTheta(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOptionsVega(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSessionFunding(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSessionRpl(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSessionUpl(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSystemName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTfaEnabled(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTotalPl(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUsername(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PrivateAccountResponseResult) validateAvailableFunds(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"available_funds", "body", m.AvailableFunds); err != nil {
		return err
	}

	return nil
}

func (m *PrivateAccountResponseResult) validateAvailableWithdrawalFunds(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"available_withdrawal_funds", "body", m.AvailableWithdrawalFunds); err != nil {
		return err
	}

	return nil
}

func (m *PrivateAccountResponseResult) validateBalance(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"balance", "body", m.Balance); err != nil {
		return err
	}

	return nil
}

func (m *PrivateAccountResponseResult) validateCurrency(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"currency", "body", m.Currency); err != nil {
		return err
	}

	return nil
}

func (m *PrivateAccountResponseResult) validateDeltaTotal(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"delta_total", "body", m.DeltaTotal); err != nil {
		return err
	}

	return nil
}

func (m *PrivateAccountResponseResult) validateEmail(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"email", "body", m.Email); err != nil {
		return err
	}

	return nil
}

func (m *PrivateAccountResponseResult) validateEquity(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"equity", "body", m.Equity); err != nil {
		return err
	}

	return nil
}

func (m *PrivateAccountResponseResult) validateFuturesPl(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"futures_pl", "body", m.FuturesPl); err != nil {
		return err
	}

	return nil
}

func (m *PrivateAccountResponseResult) validateFuturesSessionRpl(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"futures_session_rpl", "body", m.FuturesSessionRpl); err != nil {
		return err
	}

	return nil
}

func (m *PrivateAccountResponseResult) validateFuturesSessionUpl(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"futures_session_upl", "body", m.FuturesSessionUpl); err != nil {
		return err
	}

	return nil
}

func (m *PrivateAccountResponseResult) validateID(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

func (m *PrivateAccountResponseResult) validateInitialMargin(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"initial_margin", "body", m.InitialMargin); err != nil {
		return err
	}

	return nil
}

func (m *PrivateAccountResponseResult) validateMaintenanceMargin(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"maintenance_margin", "body", m.MaintenanceMargin); err != nil {
		return err
	}

	return nil
}

func (m *PrivateAccountResponseResult) validateOptionsDelta(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"options_delta", "body", m.OptionsDelta); err != nil {
		return err
	}

	return nil
}

func (m *PrivateAccountResponseResult) validateOptionsGamma(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"options_gamma", "body", m.OptionsGamma); err != nil {
		return err
	}

	return nil
}

func (m *PrivateAccountResponseResult) validateOptionsPl(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"options_pl", "body", m.OptionsPl); err != nil {
		return err
	}

	return nil
}

func (m *PrivateAccountResponseResult) validateOptionsSessionRpl(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"options_session_rpl", "body", m.OptionsSessionRpl); err != nil {
		return err
	}

	return nil
}

func (m *PrivateAccountResponseResult) validateOptionsSessionUpl(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"options_session_upl", "body", m.OptionsSessionUpl); err != nil {
		return err
	}

	return nil
}

func (m *PrivateAccountResponseResult) validateOptionsTheta(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"options_theta", "body", m.OptionsTheta); err != nil {
		return err
	}

	return nil
}

func (m *PrivateAccountResponseResult) validateOptionsVega(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"options_vega", "body", m.OptionsVega); err != nil {
		return err
	}

	return nil
}

func (m *PrivateAccountResponseResult) validateSessionFunding(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"session_funding", "body", m.SessionFunding); err != nil {
		return err
	}

	return nil
}

func (m *PrivateAccountResponseResult) validateSessionRpl(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"session_rpl", "body", m.SessionRpl); err != nil {
		return err
	}

	return nil
}

func (m *PrivateAccountResponseResult) validateSessionUpl(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"session_upl", "body", m.SessionUpl); err != nil {
		return err
	}

	return nil
}

func (m *PrivateAccountResponseResult) validateSystemName(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"system_name", "body", m.SystemName); err != nil {
		return err
	}

	return nil
}

func (m *PrivateAccountResponseResult) validateTfaEnabled(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"tfa_enabled", "body", m.TfaEnabled); err != nil {
		return err
	}

	return nil
}

func (m *PrivateAccountResponseResult) validateTotalPl(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"total_pl", "body", m.TotalPl); err != nil {
		return err
	}

	return nil
}

var privateAccountResponseResultTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["main","subaccount"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		privateAccountResponseResultTypeTypePropEnum = append(privateAccountResponseResultTypeTypePropEnum, v)
	}
}

const (

	// PrivateAccountResponseResultTypeMain captures enum value "main"
	PrivateAccountResponseResultTypeMain string = "main"

	// PrivateAccountResponseResultTypeSubaccount captures enum value "subaccount"
	PrivateAccountResponseResultTypeSubaccount string = "subaccount"
)

// prop value enum
func (m *PrivateAccountResponseResult) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, privateAccountResponseResultTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PrivateAccountResponseResult) validateType(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"type", "body", m.Type); err != nil {
		return err
	}

	// value enum
	if err := m.validateTypeEnum("result"+"."+"type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

func (m *PrivateAccountResponseResult) validateUsername(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"username", "body", m.Username); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PrivateAccountResponseResult) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PrivateAccountResponseResult) UnmarshalBinary(b []byte) error {
	var res PrivateAccountResponseResult
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
