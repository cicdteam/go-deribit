// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// PrivateOrderstateResponse private orderstate response
//
// swagger:model private_orderstate_response
type PrivateOrderstateResponse struct {

	// result
	// Required: true
	Result *PrivateOrderstateResponseResult `json:"result"`
}

// Validate validates this private orderstate response
func (m *PrivateOrderstateResponse) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateResult(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PrivateOrderstateResponse) validateResult(formats strfmt.Registry) error {

	if err := validate.Required("result", "body", m.Result); err != nil {
		return err
	}

	if m.Result != nil {
		if err := m.Result.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("result")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PrivateOrderstateResponse) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PrivateOrderstateResponse) UnmarshalBinary(b []byte) error {
	var res PrivateOrderstateResponse
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// PrivateOrderstateResponseResult private orderstate response result
//
// swagger:model PrivateOrderstateResponseResult
type PrivateOrderstateResponseResult struct {

	// advanced type (`false`, or `"usd"` or `"implv"`)
	// Required: true
	Adv *bool `json:"adv"`

	// true - created with API
	// Required: true
	API *bool `json:"api"`

	// average fill price of the order
	// Required: true
	AvgPrice *float64 `json:"avgPrice"`

	// Commission paid so far (in BTC)
	// Required: true
	Commission *float64 `json:"commission"`

	// The timestamp (in ms) that the order was created
	// Required: true
	Created *int64 `json:"created"`

	// direction, "buy" or "sell"
	// Required: true
	Direction *string `json:"direction"`

	// Defines trigger type, required for stop limit orders, possible values `"index_price"`, `"mark_price"`  (Only valid for stop orders)
	// Required: true
	ExecInst *string `json:"execInst"`

	// The number of contracts already filled
	// Required: true
	FilledQuantity *float64 `json:"filledQuantity"`

	// Option implied volatility in percent. (Only when `adv=implv`)
	// Required: true
	Implv *float64 `json:"implv"`

	// instrument name of the order
	// Required: true
	Instrument *string `json:"instrument"`

	// user defined label (up to 32 characters)
	// Required: true
	Label *string `json:"label"`

	// The timestamp (in ms) that the order was last updated
	// Required: true
	LastUpdate *int64 `json:"lastUpdate"`

	// Maximum quantity within an order to be shown to other customers, 0 for invisible order.
	// Required: true
	MaxShow *float64 `json:"max_show"`

	// id of the order
	// Required: true
	OrderID *float64 `json:"orderId"`

	// true for post-only orders only
	// Required: true
	PostOnly *bool `json:"postOnly"`

	// price
	// Required: true
	Price *float64 `json:"price"`

	// The number of contracts to be traded
	// Required: true
	Quantity *float64 `json:"quantity"`

	// order state
	// Required: true
	State *string `json:"state"`

	// stop price (Only for future stop orders)
	// Required: true
	StopPx *float64 `json:"stopPx"`

	// Whether the stop order has been triggered (Only for future stop orders)
	// Required: true
	Triggered *bool `json:"triggered"`

	// order type, `"limit"`, `"market"`, `"stop_limit"`
	// Required: true
	Type *string `json:"type"`

	// Option price in USD (Only if `adv=usd`)
	// Required: true
	Usd *float64 `json:"usd"`
}

// Validate validates this private orderstate response result
func (m *PrivateOrderstateResponseResult) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAdv(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAPI(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAvgPrice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCommission(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDirection(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExecInst(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFilledQuantity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateImplv(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInstrument(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLabel(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastUpdate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMaxShow(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrderID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePostOnly(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQuantity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStopPx(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTriggered(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUsd(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PrivateOrderstateResponseResult) validateAdv(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"adv", "body", m.Adv); err != nil {
		return err
	}

	return nil
}

func (m *PrivateOrderstateResponseResult) validateAPI(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"api", "body", m.API); err != nil {
		return err
	}

	return nil
}

func (m *PrivateOrderstateResponseResult) validateAvgPrice(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"avgPrice", "body", m.AvgPrice); err != nil {
		return err
	}

	return nil
}

func (m *PrivateOrderstateResponseResult) validateCommission(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"commission", "body", m.Commission); err != nil {
		return err
	}

	return nil
}

func (m *PrivateOrderstateResponseResult) validateCreated(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"created", "body", m.Created); err != nil {
		return err
	}

	return nil
}

func (m *PrivateOrderstateResponseResult) validateDirection(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"direction", "body", m.Direction); err != nil {
		return err
	}

	return nil
}

func (m *PrivateOrderstateResponseResult) validateExecInst(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"execInst", "body", m.ExecInst); err != nil {
		return err
	}

	return nil
}

func (m *PrivateOrderstateResponseResult) validateFilledQuantity(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"filledQuantity", "body", m.FilledQuantity); err != nil {
		return err
	}

	return nil
}

func (m *PrivateOrderstateResponseResult) validateImplv(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"implv", "body", m.Implv); err != nil {
		return err
	}

	return nil
}

func (m *PrivateOrderstateResponseResult) validateInstrument(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"instrument", "body", m.Instrument); err != nil {
		return err
	}

	return nil
}

func (m *PrivateOrderstateResponseResult) validateLabel(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"label", "body", m.Label); err != nil {
		return err
	}

	return nil
}

func (m *PrivateOrderstateResponseResult) validateLastUpdate(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"lastUpdate", "body", m.LastUpdate); err != nil {
		return err
	}

	return nil
}

func (m *PrivateOrderstateResponseResult) validateMaxShow(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"max_show", "body", m.MaxShow); err != nil {
		return err
	}

	return nil
}

func (m *PrivateOrderstateResponseResult) validateOrderID(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"orderId", "body", m.OrderID); err != nil {
		return err
	}

	return nil
}

func (m *PrivateOrderstateResponseResult) validatePostOnly(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"postOnly", "body", m.PostOnly); err != nil {
		return err
	}

	return nil
}

func (m *PrivateOrderstateResponseResult) validatePrice(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"price", "body", m.Price); err != nil {
		return err
	}

	return nil
}

func (m *PrivateOrderstateResponseResult) validateQuantity(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"quantity", "body", m.Quantity); err != nil {
		return err
	}

	return nil
}

func (m *PrivateOrderstateResponseResult) validateState(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"state", "body", m.State); err != nil {
		return err
	}

	return nil
}

func (m *PrivateOrderstateResponseResult) validateStopPx(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"stopPx", "body", m.StopPx); err != nil {
		return err
	}

	return nil
}

func (m *PrivateOrderstateResponseResult) validateTriggered(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"triggered", "body", m.Triggered); err != nil {
		return err
	}

	return nil
}

func (m *PrivateOrderstateResponseResult) validateType(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

func (m *PrivateOrderstateResponseResult) validateUsd(formats strfmt.Registry) error {

	if err := validate.Required("result"+"."+"usd", "body", m.Usd); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PrivateOrderstateResponseResult) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PrivateOrderstateResponseResult) UnmarshalBinary(b []byte) error {
	var res PrivateOrderstateResponseResult
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
